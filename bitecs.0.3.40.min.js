var bitecs;(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Changed:()=>de,DESERIALIZE_MODE:()=>R,Not:()=>ye,Types:()=>lt,addComponent:()=>De,addEntity:()=>ie,commitRemovals:()=>Ie,createWorld:()=>et,defineComponent:()=>Qe,defineDeserializer:()=>D,defineQuery:()=>Te,defineSerializer:()=>$,defineSystem:()=>it,deleteWorld:()=>rt,enableManualEntityRecycling:()=>tt,enterQuery:()=>ve,entityExists:()=>ce,exitQuery:()=>Me,flushRemovedEntities:()=>se,getAllEntities:()=>st,getEntityComponents:()=>le,getWorldComponents:()=>ot,hasComponent:()=>ze,parentArray:()=>C,pipe:()=>at,registerComponent:()=>qe,registerComponents:()=>$e,removeComponent:()=>Ye,removeEntity:()=>ae,removeQuery:()=>xe,resetChangedQuery:()=>ke,resetGlobals:()=>te,resetWorld:()=>nt,setDefaultSize:()=>ne,setRemovedRecycleThreshold:()=>re});var n={i8:"i8",ui8:"ui8",ui8c:"ui8c",i16:"i16",ui16:"ui16",i32:"i32",ui32:"ui32",f32:"f32",f64:"f64",eid:"eid"},r={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},o={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},s=(4,e=>4*Math.ceil(e/4)),i=Symbol("storeRef"),a=Symbol("storeSize"),l=Symbol("storeMaps"),c=Symbol("storeFlattened"),u=Symbol("storeBase"),f=Symbol("storeType"),y=Symbol("storeArrayElementCounts"),d=Symbol("storeSubarrays"),h=Symbol("subarrayCursors"),m=Symbol("subarray"),g=(Symbol("subarrayFrom"),Symbol("subarrayTo"),Symbol("parentArray")),b=Symbol("tagStore"),p=(Symbol("queryShadow"),Symbol("serializeShadow"),Symbol("indexType")),E=Symbol("indexBytes"),S=Symbol("isEidType"),w={},A=(e,t)=>{const n=new ArrayBuffer(t*e.BYTES_PER_ELEMENT),r=new e.constructor(n);return r.set(e,0),r},v=(e,t)=>{if(ArrayBuffer.isView(e))e[t]=e.slice(0);else{const n=e[g].slice(0);e[t]=e.map(((t,r)=>{const{length:o}=e[r],s=o*r,i=s+o;return n.subarray(s,i)}))}},M=(e,t)=>{e[c]&&e[c].forEach((e=>{ArrayBuffer.isView(e)?e[t]=0:e[t].fill(0)}))},C=e=>e[g],O=e=>Array.isArray(e)&&"string"==typeof e[0]&&"number"==typeof e[1],P=()=>{const e=[],t=[];e.sort=function(n){const r=Array.prototype.sort.call(this,n);for(let n=0;n<e.length;n++)t[e[n]]=n;return r};const n=n=>e[t[n]]===n;return{add:r=>{n(r)||(t[r]=e.push(r)-1)},remove:r=>{if(!n(r))return;const o=t[r],s=e.pop();s!==r&&(e[o]=s,t[s]=o)},has:n,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0}}},R={REPLACE:0,APPEND:1,MAP:2},T=!1,j=(e,t)=>e.concat(t),_=e=>t=>!e(t),B=e=>e[c],I=B,U=_(I),k=e=>"function"==typeof e&&e[ue],x=_(k),N=e=>k(e)&&"changed"===e()[1],L=e=>Object.getOwnPropertySymbols(e).includes(Ne),Q=e=>e()[0],q=e=>{if(L(e))return[[],new Map];const t=e.filter(x).filter(I).map(B).reduce(j,[]),n=e.filter(N).map(Q).filter(I).map(B).reduce(j,[]),r=e.filter(x).filter(U),o=e.filter(N).map(Q).filter(U);return[[...t,...r,...n,...o],[...n,...o].reduce(((e,t)=>{const n=Symbol();return v(t,n),e.set(t,n),e}),new Map)]},$=(e,t=2e7)=>{const n=L(e);let[r,o]=q(e);const s=new ArrayBuffer(t),i=new DataView(s),a=new Map;return t=>{let l;T&&([r,o]=q(e),T=!1),n&&(r=[],e[Ne].forEach(((e,t)=>{t[c]?r.push(...t[c]):r.push(t)}))),Object.getOwnPropertySymbols(t).includes(Ne)?(l=t,t=t[W]):l=oe.get(t[0]);let f=0;if(!t.length)return s.slice(0,f);const y=new Map;for(let e=0;e<r.length;e++){const n=r[e],s=n[u](),c=o.get(n),d=c?n[c]:null;y.has(s)||y.set(s,new Map),i.setUint8(f,e),f+=1;const h=f;f+=4;let m=0;for(let e=0;e<t.length;e++){const r=t[e];let o=a.get(r);o||(o=a.set(r,new Set).get(r)),o.add(r);const c=d&&y.get(s).get(r)||!o.has(s)&&ze(l,s,r);if(y.get(s).set(r,c),c)o.add(s);else if(!ze(l,s,r)){o.delete(s);continue}const u=f;if(i.setUint32(f,r),f+=4,n[b])m++;else if(ArrayBuffer.isView(n[r])){const e=n[r].constructor.name.replace("Array",""),t=n[r][p],o=n[r][E],s=f;f+=o;let a=0;for(let s=0;s<n[r].length;s++){if(d){const e=d[r][s]!==n[r][s];if(d[r][s]=n[r][s],!e&&!c)continue}i[`set${t}`](f,s),f+=o;const l=n[r][s];i[`set${e}`](f,l),f+=n[r].BYTES_PER_ELEMENT,a++}if(!(a>0)){f=u;continue}i[`set${t}`](s,a),m++}else{if(d){const e=d[r]!==n[r];if(d[r]=n[r],!e&&!c){f=u;continue}}const e=n.constructor.name.replace("Array","");i[`set${e}`](f,n[r]),f+=n.BYTES_PER_ELEMENT,m++}}m>0?i.setUint32(h,m):f-=5}return s.slice(0,f)}},z=new Map,D=e=>{const t=Object.getOwnPropertySymbols(e).includes(Ne);let[n]=q(e);const r=new Set;return(o,s,i=0)=>{z.clear(),T&&([n]=q(e),T=!1),t&&(n=[],e[Ne].forEach(((e,t)=>{t[c]?n.push(...t[c]):n.push(t)})));const a=o[Ge],l=o[Ze],f=new DataView(s);let y=0;for(;y<s.byteLength;){const e=f.getUint8(y);y+=1;const t=f.getUint32(y);y+=4;const s=n[e];for(let e=0;e<t;e++){let e=f.getUint32(y);if(y+=4,i===R.MAP)if(a.has(e))e=a.get(e);else if(z.has(e))e=z.get(e);else{const t=ie(o);a.set(e,t),l.set(t,e),z.set(e,t),e=t}if(i===R.APPEND||i===R.REPLACE&&!o[F].has(e)){const t=z.get(e)||ie(o);z.set(e,t),e=t}const t=s[u]();if(ze(o,t,e)||De(o,t,e),r.add(e),!t[b])if(ArrayBuffer.isView(s[e])){const t=s[e],n=f[`get${t[p]}`](y);y+=t[E];for(let r=0;r<n;r++){const n=f[`get${t[p]}`](y);y+=t[E];const r=f[`get${t.constructor.name.replace("Array","")}`](y);if(y+=t.BYTES_PER_ELEMENT,s[S]){let t;if(a.has(r))t=a.get(r);else if(z.has(r))t=z.get(r);else{const e=ie(o);a.set(r,e),l.set(e,r),z.set(r,e),t=e}s[e][n]=t}else s[e][n]=r}}else{const t=f[`get${s.constructor.name.replace("Array","")}`](y);if(y+=s.BYTES_PER_ELEMENT,s[S]){let n;if(a.has(t))n=a.get(t);else if(z.has(t))n=z.get(t);else{const e=ie(o);a.set(t,e),l.set(e,t),z.set(t,e),n=e}s[e]=n}else s[e]=t}}}const d=Array.from(r);return r.clear(),d}},Y=Symbol("entityMasks"),V=Symbol("entityComponents"),F=Symbol("entitySparseSet"),W=Symbol("entityArray"),J=(Symbol("entityIndices"),Symbol("removedEntities"),1e5),G=0,Z=J,H=()=>Z,K=[],X=[],ee=.01,te=()=>{Z=J,G=0,ee=.01,K.length=0,X.length=0},ne=e=>{J=e,te(),Z=e,Xe(e),T=!0},re=e=>{ee=e},oe=new Map,se=e=>{if(!e[He])throw new Error("bitECS - cannot flush removed entities, enable feature with the enableManualEntityRecycling function");K.push(...X),X.length=0},ie=e=>{const t=e[He]?K.length?K.shift():G++:K.length>Math.round(Z*ee)?K.shift():G++;if(t>e[Ve])throw new Error("bitECS - max entities reached");return e[F].add(t),oe.set(t,e),e[me].forEach((n=>{je(e,n,t)&&_e(n,t)})),e[V].set(t,new Set),t},ae=(e,t)=>{if(e[F].has(t)){e[he].forEach((n=>{Ue(e,n,t)})),e[He]?X.push(t):K.push(t),e[F].remove(t),e[V].delete(t),e[Ge].delete(e[Ze].get(t)),e[Ze].delete(t);for(let n=0;n<e[Y].length;n++)e[Y][n][t]=0}},le=(e,t)=>{if(void 0===t)throw new Error("bitECS - entity is undefined.");if(!e[F].has(t))throw new Error("bitECS - entity does not exist in the world.");return Array.from(e[V].get(t))},ce=(e,t)=>e[F].has(t),ue=Symbol("$modifier");function fe(e,t){const n=()=>[e,t];return n[ue]=!0,n}var ye=e=>fe(e,"not"),de=e=>fe(e,"changed"),he=Symbol("queries"),me=Symbol("notQueries"),ge=Symbol("queryAny"),be=Symbol("queryAll"),pe=Symbol("queryNone"),Ee=Symbol("queryMap"),Se=Symbol("$dirtyQueries"),we=Symbol("queryComponents"),Ae=(Symbol("enterQuery"),Symbol("exitQuery"),Object.freeze([])),ve=e=>t=>{t[Ee].has(e)||Ce(t,e);const n=t[Ee].get(e);if(0===n.entered.dense.length)return Ae;{const e=n.entered.dense.slice();return n.entered.reset(),e}},Me=e=>t=>{t[Ee].has(e)||Ce(t,e);const n=t[Ee].get(e);if(0===n.exited.dense.length)return Ae;{const e=n.exited.dense.slice();return n.exited.reset(),e}},Ce=(e,t)=>{const n=[],r=[],o=[];t[we].forEach((t=>{if("function"==typeof t&&t[ue]){const[s,i]=t();e[Ne].has(s)||qe(e,s),"not"===i&&r.push(s),"changed"===i&&(o.push(s),n.push(s))}else e[Ne].has(t)||qe(e,t),n.push(t)}));const s=t=>e[Ne].get(t),i=n.concat(r).map(s),a=P(),l=P(),u=P(),f=P(),y=i.map((e=>e.generationId)).reduce(((e,t)=>(e.includes(t)||e.push(t),e)),[]),d=(e,t)=>(e[t.generationId]||(e[t.generationId]=0),e[t.generationId]|=t.bitflag,e),h=n.map(s).reduce(d,{}),m=r.map(s).reduce(d,{}),g=i.reduce(d,{}),p=n.filter((e=>!e[b])).map((e=>Object.getOwnPropertySymbols(e).includes(c)?e[c]:[e])).reduce(((e,t)=>e.concat(t)),[]),E=Object.assign(a,{archetypes:[],changed:[],components:n,notComponents:r,changedComponents:o,allComponents:i,masks:h,notMasks:m,hasMasks:g,generations:y,flatProps:p,toRemove:l,entered:u,exited:f,shadows:[]});e[Ee].set(t,E),e[he].add(E),i.forEach((e=>{e.queries.add(E)})),r.length&&e[me].add(E);for(let t=0;t<G;t++)e[F].has(t)&&je(e,E,t)&&_e(E,t)},Oe=(e,t)=>{const n=Symbol(),r=e.flatProps[t];return v(r,n),e.shadows[t]=r[n],r[n]},Pe=(e,t)=>e.concat(t),Re=e=>t=>t.filter((t=>t.name===e().constructor.name)).reduce(Pe),Te=(Re((function(...e){return function(){return e}})),Re((function(...e){return function(){return e}})),Re((function(...e){return function(){return e}})),(...e)=>{let t;if(Array.isArray(e[0])&&(t=e[0]),void 0===t||void 0!==t[Ne])return e=>e?e[W]:t[W];const n=function(e,t=!0){e[Ee].has(n)||Ce(e,n);const r=e[Ee].get(n);return Ie(e),r.changedComponents.length?((e,t)=>{t&&(e.changed=[]);const{flatProps:n,shadows:r}=e;for(let t=0;t<e.dense.length;t++){const o=e.dense[t];let s=!1;for(let t=0;t<n.length;t++){const i=n[t],a=r[t]||Oe(e,t);if(ArrayBuffer.isView(i[o])){for(let e=0;e<i[o].length;e++)if(i[o][e]!==a[o][e]){s=!0;break}a[o].set(i[o])}else i[o]!==a[o]&&(s=!0,a[o]=i[o])}s&&e.changed.push(o)}return e.changed})(r,t):r.dense};return n[we]=t,n[ge]=void 0,n[be]=void 0,n[pe]=void 0,n}),je=(e,t,n)=>{const{masks:r,notMasks:o,generations:s}=t;for(let t=0;t<s.length;t++){const i=s[t],a=r[i],l=o[i],c=e[Y][i][n];if(l&&0!=(c&l))return!1;if(a&&(c&a)!==a)return!1}return!0},_e=(e,t)=>{e.toRemove.remove(t),e.entered.add(t),e.add(t)},Be=e=>{for(let t=e.toRemove.dense.length-1;t>=0;t--){const n=e.toRemove.dense[t];e.toRemove.remove(n),e.remove(n)}},Ie=e=>{e[Se].size&&(e[Se].forEach(Be),e[Se].clear())},Ue=(e,t,n)=>{t.has(n)&&!t.toRemove.has(n)&&(t.toRemove.add(n),e[Se].add(t),t.exited.add(n))},ke=(e,t)=>{e[Ee].get(t).changed=[]},xe=(e,t)=>{const n=e[Ee].get(t);e[he].delete(n),e[Ee].delete(t)},Ne=Symbol("componentMap"),Le=[],Qe=(e,t)=>{const A=((e,t)=>{const A=Symbol("store");if(!e||!Object.keys(e).length)return w[A]={[a]:t,[b]:!0,[u]:()=>w[A]},w[A];e=JSON.parse(JSON.stringify(e));const v={},M=e=>{const t=Object.keys(e);for(const n of t)O(e[n])?(v[e[n][0]]||(v[e[n][0]]=0),v[e[n][0]]+=e[n][1]):e[n]instanceof Object&&M(e[n])};M(e);const C={[a]:t,[l]:{},[d]:{},[i]:A,[h]:Object.keys(o).reduce(((e,t)=>({...e,[t]:0})),{}),[c]:[],[y]:v};if(e instanceof Object&&Object.keys(e).length){const i=(e,l)=>{if("string"==typeof e[l])e[l]=((e,t)=>{const r=t*o[e].BYTES_PER_ELEMENT,s=new ArrayBuffer(r),i=new o[e](s);return i[S]=e===n.eid,i})(e[l],t),e[l][u]=()=>w[A],C[c].push(e[l]);else if(O(e[l])){const[t,i]=e[l];e[l]=((e,t,i)=>{const l=e[a],c=Array(l).fill(0);c[f]=t,c[S]=t===n.eid;const u=e[h],b=i<=256?n.ui8:i<=65536?n.ui16:n.ui32;if(!i)throw new Error("bitECS - Must define component array length");if(!o[t])throw new Error(`bitECS - Invalid component array property type ${t}`);if(!e[d][t]){const n=e[y][t],i=new o[t](s(n*l));i[p]=r[b],i[E]=o[b].BYTES_PER_ELEMENT,e[d][t]=i}const w=u[t],A=w+l*i;u[t]=A,c[g]=e[d][t].subarray(w,A);for(let e=0;e<l;e++){const t=i*e,n=t+i;c[e]=c[g].subarray(t,n),c[e][p]=r[b],c[e][E]=o[b].BYTES_PER_ELEMENT,c[e][m]=!0}return c})(C,t,i),e[l][u]=()=>w[A],C[c].push(e[l])}else e[l]instanceof Object&&(e[l]=Object.keys(e[l]).reduce(i,e[l]));return e};return w[A]=Object.assign(Object.keys(e).reduce(i,e),C),w[A][u]=()=>w[A],w[A]}})(e,t||H());return e&&Object.keys(e).length&&Le.push(A),A},qe=(e,t)=>{if(!t)throw new Error("bitECS - Cannot register null or undefined component");const n=new Set,r=new Set,o=new Set;e[he].forEach((e=>{e.allComponents.includes(t)&&n.add(e)})),e[Ne].set(t,{generationId:e[Y].length-1,bitflag:e[We],store:t,queries:n,notQueries:r,changedQueries:o}),(e=>{e[We]*=2,e[We]>=2**31&&(e[We]=1,e[Y].push(new Uint32Array(e[Ve])))})(e)},$e=(e,t)=>{t.forEach((t=>qe(e,t)))},ze=(e,t,n)=>{const r=e[Ne].get(t);if(!r)return!1;const{generationId:o,bitflag:s}=r;return(e[Y][o][n]&s)===s},De=(e,t,n,r=!1)=>{if(void 0===n)throw new Error("bitECS - entity is undefined.");if(!e[F].has(n))throw new Error("bitECS - entity does not exist in the world.");if(e[Ne].has(t)||qe(e,t),ze(e,t,n))return;const o=e[Ne].get(t),{generationId:s,bitflag:i,queries:a,notQueries:l}=o;e[Y][s][n]|=i,a.forEach((t=>{t.toRemove.remove(n);const r=je(e,t,n);r&&(t.exited.remove(n),_e(t,n)),r||(t.entered.remove(n),Ue(e,t,n))})),e[V].get(n).add(t),r&&M(t,n)},Ye=(e,t,n,r=!0)=>{if(void 0===n)throw new Error("bitECS - entity is undefined.");if(!e[F].has(n))throw new Error("bitECS - entity does not exist in the world.");if(!ze(e,t,n))return;const o=e[Ne].get(t),{generationId:s,bitflag:i,queries:a}=o;e[Y][s][n]&=~i,a.forEach((t=>{t.toRemove.remove(n);const r=je(e,t,n);r&&(t.exited.remove(n),_e(t,n)),r||(t.entered.remove(n),Ue(e,t,n))})),e[V].get(n).delete(t),r&&M(t,n)},Ve=Symbol("size"),Fe=Symbol("resizeThreshold"),We=Symbol("bitflag"),Je=Symbol("archetypes"),Ge=Symbol("localEntities"),Ze=Symbol("localEntityLookup"),He=Symbol("manualEntityRecycling"),Ke=[],Xe=e=>{Ke.forEach((t=>{t[Ve]=e;for(let n=0;n<t[Y].length;n++){const r=t[Y][n];t[Y][n]=A(r,e)}t[Fe]=t[Ve]-t[Ve]/5}))},et=(...e)=>{const t="object"==typeof e[0]?e[0]:{},n="number"==typeof e[0]?e[0]:"number"==typeof e[1]?e[1]:H();return nt(t,n),Ke.push(t),t},tt=e=>{e[He]=!0},nt=(e,t=H())=>(e[Ve]=t,e[W]&&e[W].forEach((t=>ae(e,t))),e[Y]=[new Uint32Array(t)],e[V]=new Map,e[Je]=[],e[F]=P(),e[W]=e[F].dense,e[We]=1,e[Ne]=new Map,e[Ee]=new Map,e[he]=new Set,e[me]=new Set,e[Se]=new Set,e[Ge]=new Map,e[Ze]=new Map,e[He]=!1,e),rt=e=>{Object.getOwnPropertySymbols(e).forEach((t=>{delete e[t]})),Object.keys(e).forEach((t=>{delete e[t]})),Ke.splice(Ke.indexOf(e),1)},ot=e=>Array.from(e[Ne].keys()),st=e=>e[F].dense.slice(0),it=e=>(t,...n)=>(e(t,...n),t),at=(...e)=>t=>{let n=t;for(let t=0;t<e.length;t++)n=(0,e[t])(n);return n},lt=n;bitecs=t})();